/*
 * FlightControl.cpp
 *
 *  Created on: Mar 28, 2012
 *      Author: imaveek
 */

#include "FlightControl.h"
#include "TimerOne.h"
#include "TimerThree.h"
#include "MPU6050.h"
#include "HMC5883L.h"
#include "LowPassFilter.h"
#include "Comp6DOF_n0m1.h"
#include "MaxBotix.h"
#include <stdlib.h>


#define GYRO_BIAS 22
#define GYRO_LPF_LEN 20
#define PWM_PERIOD 100
#define PID_PERIOD 10000UL

#define DUTY_MIN 0
#define DUTY_MAX 1024
#define ALT_PID_FREQ_DIV 10

#define THROTTLE_MAX 900
#define THROTTLE_MIN 600

#define THROTTLE_SET 750
#define THROTTLE_DELTA 10

#define THROTTLE_LAND_DELTA 40

#define TURN_GYRO_SET_OFFSET 5000

#define HOVER_TIME 1000
#define TAKEOFF_TIME 2000
#define TURN_TIME 2000

#define HOVER_HEIGHT 2

#define ACC_MAX 5000
#define ACC_MIN 500

void * pointerToObj;
static void wrapper();

float turnStop = 0;
int8_t turnDir;

int16_t oldGyroSetPoint = 0;
int16_t oldAccZSetPoint = 0;
unsigned long hoverStart=0;
unsigned long takeOffStart=0;
unsigned long loopCounter=0;
unsigned long turnStart=0;
unsigned long landStart=0;

FlightControl FlightControl1;
Comp6DOF_n0m1 sixDOF;


void FlightControl::initialize() {
	// Initialize values
	yawPIDenabled = false;
	altPIDenabled = false;
	gyroBias = 0;
	accZbias = 0;
	accZsetPoint = 0;
	gyroSetPoint = 0;

	dt = 0.01;//PID_PERIOD/1000000UL;

	throttle = 0;
	yawInput=0;
	topRotDuty=0;
	botRotDuty=0;
	gz=0;
	alt=0;
	heading=0;
	gyrosum = 0;
	velZ=0;
	dispZ=0;

	yawPID = new PID(0.1,0,0,200,dt,200,-200);
	altPID = new PID(0.3,0,0,200,dt,250,-250);

	flightMode = Idle;

	// *************** Motor PWM *******************
	// set a timer of length 100 microseconds
	// Needed to set the mode 8 for phase and frequency correct PWM
	Timer1.initialize(PWM_PERIOD);
	Timer1.pwm(MOTOR1_PIN, 0, PWM_PERIOD); // PWM frequency 10000Hz
	Timer1.pwm(MOTOR2_PIN, 0, PWM_PERIOD);

	pinMode(MOTOR3_PIN, OUTPUT);
	pinMode(MOTOR3_DIR_PIN,OUTPUT);
	digitalWrite(MOTOR3_DIR_PIN,LOW);

	// *************** PID Control *****************
	Timer3.initialize(PID_PERIOD); // Timer 3, 10000us, 100Hz
	pointerToObj = this;
	Timer3.attachInterrupt(wrapper, PID_PERIOD);

	// initialize device
	Serial1.println("Initializing Accel/Gyro ...");
	AccelGyro.initialize();
	AccelGyro.setI2CBypassEnabled(HIGH);
	AccelGyro.setDLPFMode(MPU6050_DLPF_BW_5);
	AccelGyro.setFullScaleGyroRange(MPU6050_GYRO_FS_1000);
	AccelGyro.setFullScaleAccelRange(MPU6050_ACCEL_FS_4);


	// verify connection
	Serial1.println("Testing Accel/Gyro connections...");
	Serial1.println(AccelGyro.testConnection() ? "MPU6050 connection successful" : "MPU6050 connection failed");
	Serial1.println(Compass.testConnection() ? "HMC5883L connection successful" : "HMC5883L connection failed");

}


// To call the main loop function in the timer interrupt
void wrapper() {
	FlightControl * mySelf =  (FlightControl *) pointerToObj;
	mySelf->mainLoop();
}

void FlightControl::mainLoop()
{
	sei();

	// Get measurements
	gz = AccelGyro.getRotationZ();
	az = AccelGyro.getAccelerationZ();
	alt = AltSensor.value();

	loopCounter++;

	switch(flightMode) {
	case Idle: idleMode(); // Do nothing. Stationary landed.
	break;
	case Hover: hoverMode(); // Maintain altitude. Can go forward in this mode.
	break;
	case TakeOff: takeOffMode(); // Increase throttle till height is achieved
	break;
	case Land: landMode(); // Decrease throttle to land smoothly
	break;
	case Turn: turnMode(); // Execute open loop turn
	break;
	}

	if (altPIDenabled) {
		altInput = altPID->loop(accZsetPoint,az);
		throttle = THROTTLE_SET + altInput;
		throttle = (throttle>THROTTLE_MAX) ? THROTTLE_MAX:throttle;
		throttle = (throttle<THROTTLE_MIN) ? THROTTLE_MIN:throttle;
		topRotDuty = throttle;
		botRotDuty = throttle;
	}

	// Fast Yaw Control loop
	if (yawPIDenabled) {
		yawInput = yawPID->loop(gyroSetPoint,gz);
		topRotDuty = throttle - yawInput;
		botRotDuty = throttle + yawInput;
	}

	// Set motor duty cycles
	setTopRotorDuty(topRotDuty);
	setBottomRotorDuty(botRotDuty);
}

inline void FlightControl::hoverMode() {
	topRotDuty = throttle;
	botRotDuty = throttle;
//	unsigned long now = millis();
//	if ((now-hoverStart) > HOVER_TIME) {
//		land();
//	}
//	altPIDenabled = true;
}

inline void FlightControl::idleMode() {
	altPIDenabled = false;
	yawPIDenabled = false;
	throttle = DUTY_MIN;
	topRotDuty = throttle;
	botRotDuty = throttle;
}

inline void FlightControl::takeOffMode() {
	unsigned long now = millis();
	if ((now-takeOffStart) > TAKEOFF_TIME) {
		land();
		return;
	}
	throttle = throttle + THROTTLE_DELTA;
	if (throttle > 100) {
		yawPIDenabled = true;
	}
	throttle = (throttle>THROTTLE_MAX) ? THROTTLE_MAX:throttle;
	topRotDuty = throttle;
	botRotDuty = throttle;
}

inline void FlightControl::landMode() {
	throttle = throttle - THROTTLE_LAND_DELTA;
	throttle = (throttle<DUTY_MIN) ? DUTY_MIN:throttle;
	if (throttle==DUTY_MIN) {
		idle();
	}
	if (throttle < 300)
		yawPIDenabled = false;
}

inline void FlightControl::turnMode() {
	gyrosum += (gz-gyroBias) * dt * 1000/32768;
	if ((turnDir * (turnStop - gyrosum)) < 0) {
		gyrosum = 0;
		gyroSetPoint = gyroBias;
		flightMode = Idle;
	}
}

void FlightControl::turn(int16_t angle) {
	gyrosum = 0;
	turnStop = angle;
	turnDir = angle/abs(angle);
	gyroSetPoint = turnDir * TURN_GYRO_SET_OFFSET;
	flightMode = Turn;
}

void FlightControl::takeOff() {
	FlightControl1.calibrateGyro();
	FlightControl1.calibrateAccZ();
	takeOffStart = millis();
	flightMode = TakeOff;
}

void FlightControl::land() {
	velZ = 0;
	dispZ = 0;
	flightMode = Land;
	altPIDenabled = false;
}

void FlightControl::forward(bool status) {
	if(status)
		digitalWrite(MOTOR3_PIN,HIGH);
	else
		digitalWrite(MOTOR3_PIN,LOW);
}

void FlightControl::hover() {
	hoverStart = millis();
	yawPIDenabled = true;
	flightMode = Hover;
}

void FlightControl::idle() {
	flightMode = Idle;
}

void FlightControl::enableYawPID(bool status) {
	this->yawPIDenabled = status;
}

void FlightControl::enableAltPID(bool status) {
	this->altPIDenabled = status;
}

void FlightControl::setTopRotorDuty(uint16_t duty) {
	static uint16_t lastDuty=0;
	// Set motor input
	if(duty <= 0){
		duty = (duty<DUTY_MIN) ? DUTY_MIN:duty;
	}
	else{
		duty = (duty>DUTY_MAX) ? DUTY_MAX:duty;
	}
	if(duty != lastDuty)
		Timer1.setPwmDuty(MOTOR1_PIN,duty);
	lastDuty = duty;
}

void FlightControl::setBottomRotorDuty(uint16_t duty) {
	static uint16_t lastDuty=0;
	if(duty <= 0){
		duty = (duty<DUTY_MIN) ? DUTY_MIN:duty;
	}
	else{
		duty = (duty>DUTY_MAX) ? DUTY_MAX:duty;
	}
	if(duty != lastDuty)
		Timer1.setPwmDuty(MOTOR2_PIN,duty);
	lastDuty = duty;
}


float FlightControl::getTiltCompensatedHeading() {
	// poll sensors for new data
	AccelGyro.getAcceleration(&ax,&ay,&az);
	Compass.getHeading(&mx,&my,&mz);
	//enter compass data and accel data for calculation
	sixDOF.compCompass(mz, -mx, my, az, ay, ay, true);
	float compHeading = sixDOF.atan2Int(sixDOF.yAxisComp(), sixDOF.xAxisComp());
	compHeading = compHeading /100;
	compHeading += 180;
	return compHeading;
}


float FlightControl::getHeading() {
	Compass.getHeading(&mx,&my,&mz);
	Serial1.print("mag:\t");
	Serial1.print(mx); Serial1.print("\t");
	Serial1.print(my); Serial1.print("\t");
	Serial1.println(mz);
	// this is correct orientation for non tilt comp - notice the result is not the same as tilt comp
	float head = atan2(mz, mx); //use the 6dof atan2 because its faster
	head = head /100;
	if (head < 0 ) {
		head += 360;
	}
	return head;
}


void FlightControl::calibrateGyro() {
	int16_t gz = 0;
	LowPassFilter glp(100);
	for(uint8_t i=0;i<100;i++) {
		delay(1);
		gz = glp.filter(AccelGyro.getRotationZ());
	}
	gyroBias = gz;
}

void FlightControl::calibrateAccZ() {
	int16_t az = 0;
	LowPassFilter alp(100);
	for(uint8_t i=0;i<100;i++) {
		delay(1);
		az = alp.filter(AccelGyro.getAccelerationZ());
	}
	accZbias = az;
}


float FlightControl::altFromAccZ() {
	static float oldVel = 0;

	float acc;
	acc = (az - accZbias);
	if (abs(acc) < ACC_MAX && abs(acc) > ACC_MIN) {
		velZ += acc * dt * 0.001;
		dispZ += ((velZ + oldVel)/2) * dt;
		oldVel = velZ;
	}
	return dispZ;
}
