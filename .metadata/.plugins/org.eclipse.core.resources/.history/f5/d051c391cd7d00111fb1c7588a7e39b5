/*
 * SRF01.cpp
 *
 *  Created on: Apr 3, 2012
 *      Author: imaveek
 */

#include "SRF01.h"

SoftwareSerial srf01 = SoftwareSerial(SRF_TXRX, SRF_TXRX);      // Sets up software serial port for the SRF01

SRF01::SRF01() {
	// TODO Auto-generated constructor stub
}

void SRF01::initialize() {
	srf01.begin(9600);
	// Make sure that the SRF01 software serial port is listening
	// for data as only one software serial port can listen at a time
	srf01.listen();

	// Waits some time to make sure everything is powered up
	delay(200);

	byte softVer;
	SRF01_Cmd(SRF_ADDRESS, GETSOFT); // Request the SRF01 software version
	while (srf01.available() < 1);
	softVer = srf01.read(); // Read software version from SRF01

	Serial1.println(softVer);
}

void SRF01::getRange() {
	 byte hByte, lByte, statusByte, b1, b2, b3;

	  SRF01_Cmd(SRF_ADDRESS, GETRANGE);                       // Get the SRF01 to perform a ranging and send the data back to the arduino
	  while (srf01.available() < 2);
	  hByte = srf01.read();                                   // Get high byte
	  lByte = srf01.read();                                   // Get low byte
	  int range = ((hByte<<8)+lByte);                         // Put them together

	  lcd03.write(LCD_SET_CUR);
	  lcd03.write(21);                                        // Move the cursor to location 21
	  lcd03.print("Range = ");
	  lcd03.print(range, DEC);                                // Print range result to the screen
	  lcd03.print("  ");                                      // Print some spaces to the screen to make sure space direcly after the result is clear

	  SRF01_Cmd(SRF_ADDRESS, GETSTATUS);                      // Request byte that will tell us if the transducer is locked or unlocked
	  while (srf01.available() < 1);
	    statusByte = srf01.read();                            // Reads the SRF01 status, The least significant bit tells us if it is locked or unlocked
	  int newStatus = statusByte & 0x01;                      // Get status of lease significan bit
	  if(newStatus == 0){
	    lcd03.write(LCD_SET_CUR);
	    lcd03.write(61);                                      // Moves the cursor to location 61
	    lcd03.print("Unlocked");                              // Prints the word unlocked followd by a couple of spaces to make sure space after has nothing in
	  }
	   else {
	    lcd03.write(LCD_SET_CUR);
	    lcd03.write(61);                                      // Moves cursor to location 61
	    lcd03.print("Locked   ");                             // Prints the word locked followd by a couple of spaces to make sure that the space after has nothing in
	  }

	  delay(100);
}

void SRF01::SRF01_Cmd(byte Address, byte cmd){               // Function to send commands to the SRF01
  pinMode(SRF_TXRX, OUTPUT);
  digitalWrite(SRF_TXRX, LOW);  // Send a 2ms break to begin communications with the SRF01
  delay(2);
  digitalWrite(SRF_TXRX, HIGH);
  delay(1);
  srf01.write(Address);   // Send the address of the SRF01
  srf01.write(cmd);   // Send commnd byte to SRF01
  pinMode(SRF_TXRX, INPUT);

  // As RX and TX are the same pin it will have recieved the data we just sent out, as
  // we dont want this we read it back and ignore it as junk before waiting for useful data to arrive
  int availbleJunk = srf01.available();
  for(int x = 0;  x < availbleJunk; x++) byte junk = srf01.read();
}

SRF01::~SRF01() {
	// TODO Auto-generated destructor stub
}




